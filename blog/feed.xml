<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title> Blog</title>
        <link>https://prestodb.io/blog</link>
        <description>The best place to stay up-to-date with the latest  news and events.</description>
        <lastBuildDate>Tue, 16 Jun 2020 06:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <image>
            <title> Blog</title>
            <url>https://prestodb.io/img/presto.png</url>
            <link>https://prestodb.io/blog</link>
        </image>
        <item>
            <title><![CDATA[Improving Presto Latencies with Alluxio Data Caching]]></title>
            <link>https://prestodb.io/blog/2020/06/16/alluxio-datacaching.html</link>
            <guid>https://prestodb.io/blog/2020/06/16/alluxio-datacaching.html</guid>
            <pubDate>Tue, 16 Jun 2020 06:00:00 GMT</pubDate>
            <description><![CDATA[<p><strong>Facebook:</strong> Rohit Jain, James Sun, Ke Wang, Shixuan Fan, Biswapesh Chattopadhyay, Baldeep Hira</p>
<p><strong>Alluxio:</strong> Bin Fan, Calvin Jia, Haoyuan Li</p>
<p>The Facebook Presto team has been collaborating with <a href="https://www.alluxio.io/">Alluxio</a> on an open source data caching solution for Presto.
This is required for multiple Facebook use-cases to improve query latency for queries that scan data from remote sources such as HDFS.
We have observed significant improvements in query latencies and IO scans in our experiments.
<br><br></p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Spatial Joins 1: Local Spatial Joins]]></title>
            <link>https://prestodb.io/blog/2020/05/07/local-spatial-joins.html</link>
            <guid>https://prestodb.io/blog/2020/05/07/local-spatial-joins.html</guid>
            <pubDate>Thu, 07 May 2020 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>A common type of spatial query involves relating one table of geometric
objects (e.g., a table <code>population_centers</code> with columns
<code>population, latitude, longitude</code>) with another such table (e.g., a table
<code>counties</code> with columns <code>county_name, boundary_wkt</code>), such as calculating
for each county the population sum of all population centers contained
within it. These kinds of calculations are called <em>spatial joins</em>. While
doing it for a single row each from <code>population_centers</code> and <code>counties</code> is
manageable, doing it efficiently for two large tables is challenging. In this
post, we'll talk about the machinery that Presto has built to make these
queries blazingly fast.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Engineering SQL Support on Apache Pinot at Uber]]></title>
            <link>https://prestodb.io/blog/2020/03/18/uber-pinot.html</link>
            <guid>https://prestodb.io/blog/2020/03/18/uber-pinot.html</guid>
            <pubDate>Wed, 18 Mar 2020 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>The article,  <a href="https://eng.uber.com/engineering-sql-support-on-apache-pinot/">Engineering SQL Support on Apache Pinot at Uber</a>, was originally published by Uber on the Uber Engineering Blog on January 15, 2020. Check out <a href="https://eng.uber.com/">eng.uber.com</a> for more articles about Uber's engineering work and follow Uber Engineering at <a href="https://twitter.com/UberEng">@UberEng</a> and Uber Open Source at <a href="https://twitter.com/UberOpenSource">@UberOpenSouce</a> on Twitter for updates from our teams.</p>
<p><img src="/img/blog/2020-03-18-uber-pinot/shiny-thing.png" alt=""></p>
<p>Uber leverages real-time analytics on aggregate data to improve the user experience across our products, from <a href="https://eng.uber.com/uber-eats-risk-team/">fighting fraudulent behavior</a> on Uber Eats to <a href="https://eng.uber.com/forecasting-introduction/">forecasting demand</a> on our platform.</p>
<p>As Uber’s operations became more complex and we offered additional features and services through our platform, we needed a way to generate more timely analytics on our aggregated marketplace data to better understand how our products were being used. Specifically, we needed our Big Data stack to support cross-table queries as well as nested queries, both requirements that would enable us to write more flexible ad hoc queries to keep up with the growth of our business.</p>
<p>To resolve these issues, we built a solution that linked <a href="http://prestodb.github.io/">Presto</a>, a query engine that supports full ANSI SQL, and <a href="https://pinot.apache.org/">Pinot</a>, a real-time OLAP (online analytical processing) datastore. This married solution allows users to write ad-hoc SQL queries, empowering teams to unlock significant analysis capabilities.</p>
<p>By engineering full SQL support on Apache Pinot, users of our Big Data stack can now write complex SQL queries as well as join different tables in Pinot with those in other datastores at Uber. This new solution enables operations teams with basic SQL knowledge to build dashboards for quick analysis and reporting on aggregated data without having to spend extra time working with engineers on data modelling or building data pipelines, leading to efficiency gains and resource savings across the company.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Querying Nested Data with Lambda Functions]]></title>
            <link>https://prestodb.io/blog/2020/03/02/presto-lambda.html</link>
            <guid>https://prestodb.io/blog/2020/03/02/presto-lambda.html</guid>
            <pubDate>Mon, 02 Mar 2020 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>Denormalized data with nested values (e.g. array/map) have become omnipresent in this Big Data era, as a lot of data naturally conforms to a nested representation [1, 2]. As a result it is important to provide an efficient and convenient way to query nested data. SQL traditionally does not include support for this.</p>
<p>The pioneering work of Dremel proposed an extension to SQL based on recursive relational algebra to allow querying nested records [1], and is now available in BigQuery and the SQL:2016 standard. The following example shows how to transform array elements with this (adapted from <a href="https://cloud.google.com/bigquery/docs/reference/standard-sql/arrays#creating-arrays-from-subqueries">BigQuery Docs</a>):</p>
<pre><code class="hljs css language-sql"><span class="hljs-keyword">SELECT</span> elements,
    <span class="hljs-built_in">ARRAY</span>(<span class="hljs-keyword">SELECT</span> v * <span class="hljs-number">2</span>
          <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">UNNEST</span>(elements) <span class="hljs-keyword">AS</span> v) <span class="hljs-keyword">AS</span> multiplied_elements
<span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">VALUES</span>
        (<span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]),
        (<span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>]),
        (<span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">64</span>])
) <span class="hljs-keyword">AS</span> t(elements)

    elements    | multiplied_elements
<span class="hljs-comment">----------------+---------------------</span>
 [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]         | [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
 [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>]      | [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">18</span>]
 [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">64</span>] | [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">32</span>, <span class="hljs-number">128</span>]
(<span class="hljs-number">3</span> <span class="hljs-keyword">rows</span>)
</code></pre>
<p>While nested relational algebra provides an elegant and unified approach to query nested data, we found it could be challenging for users to track the “unnest stack” in mind when writing the query. In our experience, users are more comfortable to apply a given function (e.g lambda) to each element in the collection. This motivates us to introduce lambda expressions into Presto to help query nested data, as illustrated below:</p>
<pre><code class="hljs css language-sql"><span class="hljs-keyword">SELECT</span> elements, 
transform(elements, v -&gt; v * <span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> multiplied_elements
<span class="hljs-keyword">FROM</span> (
    <span class="hljs-keyword">VALUES</span>
        (<span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]),
        (<span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>]),
        (<span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">64</span>])
) <span class="hljs-keyword">AS</span> t(elements)
</code></pre>
<p>In Presto, a lambda expression consists of an argument list and lambda body, separated by <code>-&gt;</code>:</p>
<pre><code class="hljs css language-sql">x -&gt; x + 1
(x, y) -&gt; x + y
x -&gt; regexp_like(x, 'a+')
x -&gt; x[1] / x[2]
x -&gt; IF(x &gt; 0, x, -x)
x -&gt; COALESCE(x, 0)
x -&gt; CAST(x AS JSON)
x -&gt; x + TRY(1 / 0)
</code></pre>
<p>Note there is no type annotation in a lambda expression. The type of a lambda expression (e.g. <code>function(integer, integer)</code>) thus has to be inferred from the context of function call. As a result, standalone lambda expressions are not allowed since their types cannot be determined.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Announcing PrestoCon 2020: Advancing the Big Data Ecosystem with Presto]]></title>
            <link>https://prestodb.io/blog/2020/02/13/prestocon-announcement.html</link>
            <guid>https://prestodb.io/blog/2020/02/13/prestocon-announcement.html</guid>
            <pubDate>Thu, 13 Feb 2020 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>On March 24, 2020 in San Mateo, the Presto Foundation, in partnership with The Linux Foundation, will be hosting the organization’s first-ever <a href="https://events.linuxfoundation.org/prestocon/">PrestoCon</a>. The event, one of the first Presto-focused full-day conferences ever held, will feature speakers...</p>]]></description>
        </item>
        <item>
            <title><![CDATA[Improving the Presto planner for better push down and data federation]]></title>
            <link>https://prestodb.io/blog/2019/12/23/improve-presto-planner.html</link>
            <guid>https://prestodb.io/blog/2019/12/23/improve-presto-planner.html</guid>
            <pubDate>Mon, 23 Dec 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p><strong>Alibaba:</strong> Yuan Mei</p>
<p><strong>Facebook:</strong> James Sun, Maria Basmanova, Rongrong Zhong, Jiexi Lin, Saksham Sachdev</p>
<p><strong>Pinterest:</strong> Yi He</p>
<p><strong>University of Waterloo:</strong> Akshay Pall</p>
<p>Presto defines a connector API that allows Presto to query any data source that has a connector implementation. The existing connector API provides basic predicate pushdown functionality allowing connectors to perform filtering at the underlying data source.</p>
<p>However, there are certain limitations with the existing predicate pushdown functionality that limits what connectors can do. The expressiveness of what can be pushed down is limited and the connectors can't change the structure of the plan at all.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[5 design choices—and 1 weird trick — to get 2x efficiency gains in Presto repartitioning]]></title>
            <link>https://prestodb.io/blog/2019/12/20/repartition.html</link>
            <guid>https://prestodb.io/blog/2019/12/20/repartition.html</guid>
            <pubDate>Fri, 20 Dec 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>Ying Su, Masha Basmanova, Orri Erling, Tim Meehan, Sahar Massachi, Bhavani Hari</p>
<p>We like Presto. We like it a lot — so much we want to make it better in every way. Here's an example: we just optimized the PartitionedOutputOperator. It's now 2-3x more CPU efficient, which, when measured against Facebook's production workload, translates to 6% gains overall. That's huge.</p>
<p>The optimized repartitioning is in use on some production Presto clusters right now, and available for use as of release 0.229.</p>
<p>In this note, let's go over how we did it, what optimizations we unlocked specifically, and a case study of how we approached opportunity sizing whether this was worth doing at all.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Join Us! Growing the Presto Foundation in 2020 and Beyond]]></title>
            <link>https://prestodb.io/blog/2019/12/16/growing-the-presto-foundation.html</link>
            <guid>https://prestodb.io/blog/2019/12/16/growing-the-presto-foundation.html</guid>
            <pubDate>Mon, 16 Dec 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>The Presto Foundation (PF) was <a href="https://www.linuxfoundation.org/press-release/2019/09/facebook-uber-twitter-and-alibaba-form-presto-foundation-to-tackle-distributed-data-processing-at-scale/">established in September 2019</a> as an openly governed and vendor-neutral body dedicated to scaling and diversifying the <a href="https://prestodb.io/">Presto</a> community. Hosted by the Linux Foundation, PF and its Governing Board are in a unique position...</p>]]></description>
        </item>
        <item>
            <title><![CDATA[Table Scan: Doing The Right Thing With Structured Types]]></title>
            <link>https://prestodb.io/blog/2019/09/26/tablescan-structs.html</link>
            <guid>https://prestodb.io/blog/2019/09/26/tablescan-structs.html</guid>
            <pubDate>Thu, 26 Sep 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>In the previous article we saw what gains are possible when filtering early and in the right order. In this article we look at how we do this with nested and structured types.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Presto now hosted under the Linux Foundation]]></title>
            <link>https://prestodb.io/blog/2019/09/23/linux-foundation.html</link>
            <guid>https://prestodb.io/blog/2019/09/23/linux-foundation.html</guid>
            <pubDate>Mon, 23 Sep 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>We are excited to announce today, in partnership with <a href="https://www.alibaba.com/">Alibaba</a>, <a href="https://www.facebook.com/">Facebook</a>, <a href="https://twitter.com/home">Twitter</a>, and <a href="https://www.uber.com">Uber</a>, the launch of the Presto Foundation, a non-profit organization under the umbrella of the <a href="https://www.linuxfoundation.org/">Linux Foundation</a>.</p> <p>Hosting by the Linux Foundation opens up the Presto...</p>]]></description>
        </item>
        <item>
            <title><![CDATA[Memory Management in Presto]]></title>
            <link>https://prestodb.io/blog/2019/08/19/memory-tracking.html</link>
            <guid>https://prestodb.io/blog/2019/08/19/memory-tracking.html</guid>
            <pubDate>Mon, 19 Aug 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>In a multi-tenant system like Presto careful memory management is required to keep the system stable and prevent individual queries from taking over all the resources. However, tracking the memory usage of data structures in an application (Presto) running on the Java Virtual Machine (JVM) requires a significant amount of work. In addition, Presto is a distributed system, which makes the problem more complicated. This post provides an overview of how memory management works in Presto, and provides info about the various memory management related JMX counters/endpoints that can be used for monitoring production clusters.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Presto Unlimited: MPP SQL Engine at Scale]]></title>
            <link>https://prestodb.io/blog/2019/08/05/presto-unlimited-mpp-database-at-scale.html</link>
            <guid>https://prestodb.io/blog/2019/08/05/presto-unlimited-mpp-database-at-scale.html</guid>
            <pubDate>Mon, 05 Aug 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>Wenlei Xie, Andrii Rosa, Shixuan Fan, Rebecca Schlussel, Tim Meehan</p>
<p>Presto is an open source distributed SQL query engine for running analytic queries against data sources of all sizes ranging from gigabytes to petabytes.</p>
<p>Presto was originally designed for interactive use cases, however, after seeing the merit in having a single interface for both batch and interactive, it is now also used heavily for processing batch workloads [6]. As a concrete example, more than 80% of new warehouse batch workloads at Facebook are developed on Presto. Its flexible “connector” design makes it possible to run queries against heterogeneous data sources — such as joining together Hive and MySQL tables without preloading the data.</p>
<p>However, memory-intensive (many TBs) and long-running (multiple hours) queries have been major pain points for Presto users. It is difficult to reason how much memory queries will use and when it will hit memory limit, and failures in long-running queries cause retries which create landing time variance. To improve user experience and scale MPP Database to large ETL workloads, we started this Presto Unlimited project.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Complete Table Scan: A Quantitative Assessment]]></title>
            <link>https://prestodb.io/blog/2019/07/23/complete-table-scan.html</link>
            <guid>https://prestodb.io/blog/2019/07/23/complete-table-scan.html</guid>
            <pubDate>Tue, 23 Jul 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>In the previous article we looked at the abstract problem statement and possibilities inherent in scanning tables. In this piece we look at the quantitative upside with Presto. We look at a number of queries and explain the findings.</p>
<p>The initial impulse motivating this work is the observation that table scan is by far the #1 operator in Presto workloads I have seen. This is a little over half of all Presto CPU, with repartitioning a distant second, at around 1/10 of the total. The other half of the motivation is ready opportunity: Presto in its pre-Aria state does almost none of the things that are common in table scan.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Everything You Always Wanted To Do in Table Scan]]></title>
            <link>https://prestodb.io/blog/2019/06/29/everything-you-always-wanted-to-do-in-a-table-scan.html</link>
            <guid>https://prestodb.io/blog/2019/06/29/everything-you-always-wanted-to-do-in-a-table-scan.html</guid>
            <pubDate>Sat, 29 Jun 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>Orri Erling, Maria Basmanova, Ying Su, Timothy Meehan, Elon Azoulay</p>
<p>Table scan, on the face of it, sounds trivial and boring. What’s there in just reading a long bunch of records from first to last? Aren’t indexing and other kinds of physical design more interesting?</p>
<p>As data has gotten bigger, the columnar table scan has only gotten more prominent. The columnar scan is a fairly safe baseline operation: The cost of writing data is low, the cost of reading it is predictable.</p>
<p>Another factor that makes the table scan the main operation is the omnipresent denormalization in data warehouse. This only goes further as a result of ubiquitous use of lists and maps and other non-first normal form data.</p>
<p>The aim of this series of articles is to lay out the full theory and practice of table scan with all angles covered. We will see that this is mostly a matter of common sense and systematic application of a few principles: Do not do extra work and do the work that you do always in bulk. Many systems like Google’s BigQuery do some subset of the optimizations outlined here. Doing all of these is however far from universal in the big data world, so there is a point in laying this all out and making a model implementation on top of Presto. We are here talking about the ORC format, but the same things apply equally to Parquet or JSON shredded into columns.</p>
]]></description>
        </item>
        <item>
            <title><![CDATA[Introducing the Presto blog]]></title>
            <link>https://prestodb.io/blog/2019/06/28/introducing-the-presto-blog.html</link>
            <guid>https://prestodb.io/blog/2019/06/28/introducing-the-presto-blog.html</guid>
            <pubDate>Fri, 28 Jun 2019 06:00:00 GMT</pubDate>
            <description><![CDATA[<p>Presto is a key piece of data infrastructure at many companies. The community has many ongoing projects for taking it to new levels of performance and functionality plus unique experience and insight into challenges of scale.</p> <p>We are opening this blog...</p>]]></description>
        </item>
    </channel>
</rss>